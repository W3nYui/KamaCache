#pragma once // 防止头文件被重复包含

// =========================================================================
// 泛型接口设计 (Templated Interface)
// 
// 1. 静态多态 (Template)：Key 和 Value 的类型在编译期确定，保证类型安全且无强制转换开销。
// 2. 动态多态 (Virtual)：put/get 的具体算法（LRU/FIFO/LFU）在运行期通过虚函数表决议。
// =========================================================================

namespace KamaCache
{

template <typename Key, typename Value> // 模板类，支持任意类型的key和value
class KICachePolicy
{
public:
    // =====================================================================
    // 虚析构函数 (Virtual Destructor)
    // 
    // 当使用基类指针 (KICachePolicy*) 指向子类对象 (LRUCache*) 并执行 delete 时：
    // - 如果不是 virtual：只会调用基类的析构函数，子类中申请的资源（如 std::map, 链表节点）
    //   将不会被释放，导致严重的【内存泄漏】。
    // - 加上 virtual：编译器会通过虚函数表找到子类的析构函数先执行，再执行基类的。
    // =====================================================================
    virtual ~KICachePolicy() {};

    // =====================================================================
    // 添加缓存数据写入接口
    // "= 0" 的含义：纯虚函数 (Pure Virtual Function)。
    // 这规定了 KICachePolicy 是一个【抽象基类 (Abstract Base Class)】，不能被实例化。
    // 它强制要求所有子类必须实现这个接口，否则子类也会变成抽象类（编译报错）。
    // =====================================================================
    virtual void put(Key key, Value value) = 0;

    // =====================================================================
    // 添加缓存数据查找接口
    // 这种 "bool + 传出参数" 的模式在高性能 C++ 中很常见，因为它避免了
    // 构造临时对象，且能明确区分“未找到”和“找到但值为空”的情况。
    virtual bool get(Key key, Value& value) = 0;
    
    // =====================================================================
    // 添加缓存数据读取接口
    // =====================================================================
    virtual Value get(Key key) = 0;

};

} // namespace KamaCache